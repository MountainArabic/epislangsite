Примечания:
    1) Обновления выпускаются при 3-9 нововведениях/исправлениях
    2) Выпуск обноления может затягиватся из-за работы над документаций(планируется 15 глав)
    3) Урезанные/убранные фичи будут в отдельной документаций, последняя версия где работала та или иная фича, что она делала, причина удаления

Дополнительно:
    В добавок ведется работа над модулем formula, который будет предоставлять доп. типы данных(wstr,wbool,matrix,xmatrix)

==== [№0] Об разработке [№0] =====
Студия: DamirDev
├・Была передана студии "EpisLangProject" на хакатон
╰・Начала работу с 29.07.2024

===== [№1] Главная информация [№1] =====
Название языка: Epis/EpisLang
Язык разработки: Python 3.12.9
Цель: Создание языка для максимально точных математических вычислений
Разработчик: Егимбаев Дамир
╰・DamirDev Studio
Создан в рамках проекта: DamirDev/EpisLangProject
Код проекта: Pj3W
Платформа: Windows 7+
Целевая аудитория: В основном для личного использования и обучения, но так-же предназначен ученым и студентам,так как ЯП предоставляет огромную синтаксическую базу для работы совсем чем только можно без импорта посторонних библиотек
Даты
├・Дата создания(v0.0.1): 04.07.25
├・Дата первого релиза(v1.0.0): 09.09.2025
╰・Дата релиза текушей версий(v1.0.7): 23.11.2025

===== [№2] Типы данных [№2] =====
По умолчанию существуют str, int, float, complex, list, tuple, set, dict, number(float с фиксированной точностью), frac(дробные числа: 1/3,5/6,234/17 итд), wlist(WorkLIST,расширенный тип данных для списков)

Унаследованные от пайтона
╭・str-от слова string, строка, для хранения текста("Hi",'Hello',"Epis-it's victorship")
├・int-от слова integer, целые числа(34,19,27,0xA5,0o71,0b10100)
├・float-числа с плавающей запятой/основана на IEEE754(3.14,0.3,2.3e3)
├・complex-числа с мнимой частью(1j,(3+4j),(8+1.6j))(Дробные часть также основанны на IEEE754)
├・Работа с несколькими данными в одном объекте
├╭・list-обычный массив(список) как в пайтоне
├├・tuple-кортеж
├├・set-множество
╰╰・dict-словарь

Собственные типы данных:
╭・number-десятичные дробные числа для точных вычеслений
├・frac-дробные числа, по типу 1/5,1/10 а также поддерживая периодические и обычные десятичные дроби, просто переводя их в обычные дроби, примеры: 0.(3)→1/3, 0.77→77/100
├・wlist-тотже список но с дополнительной функцией groupby для групировок через лямбды или функций(с одним принимаемым аргументом)
╰・xc - eXtended Complex, тотже complex, но с фиксированной точностью благодоря number

Подробнее в разделе №3 «Работа с типами»

===== [№3] Работа с типами [№3] =====
Все унаследованые типы работает также как в пайтон

Number: 
    a = num('0.1')
    b = num(7.8,1) #второе число это точность после запятой, если не указать, по умолчанию 256, также лучше передавать строки,ради сохранения точности
    #начиная с версий 1.0.2 не обязательно создавать экземляр класса number
    c = 10N #Начиная с версий 1.0.3 у Number появился литерал(суффикс N)
    d = 0.1N # num('0.1') -> 0.1 с точность 256 после запятой(значение по умолчанию)
    e = 0.33:1N # num('0.33',1) -> 0.3 с точностью 1 после запятой(указанна)

При складываний с int, float возвращяется number, но для складывания с frac нужно преобразовать через num('0.1').frac() либо сделать обратное через frac('1/10').numb(x) # x - это точность после запятой

Frac: 
    a = frac('619/913')
    b = frac(23) #23/1
    c = frac('0.(1)') #1/9
    d = frac('0.43') #43/100
    e = 10F #Начиная с версий 1.0.3 у Frac появился литерал(суффикс F)
    f = 1/10F # frac('1/10') -> 1/10
    g = 0.1F # frac('0.1') -> 1/10
    h = 0.(3)F # frac('0.(3)') -> 1/3

wlist:
    a = wlist([0,1,2,3,4,5,6,7,8,9])
    a.groupby(lambda x: x%3+1) # вернет словарь:{1:[0,3,6,9],2:[1,4,7],3:[2,5,8]}
    a + [0] #вернет wlist([0,1,2,3,4,5,6,7,8,9,0])
    '23' + a #вернет wlist(['2','3',0,1,2,3,4,5,6,7,8,9]), сначало итерирует слогаемое как список, и складывает, то же самое происхожит и с сложением выше
    a - (9,3) # вернет wlist([0,1,2,4,5,6,7,8]), удаляет все элементы вычитаемого
    [0,1,2,56,71] - a #возвращяет wlist([56,71]), удаляет из первого все элементы a
    a * 3 # [0,1,2,3,4,5,6,7,8,9,0,1,2,3,4,5,6,7,8,9,0,1,2,3,4,5,6,7,8,9]
    3 * a # тоже самое
    a * 1.2 #[0,1,2,3,4,5,6,7,8,9,0,1], 1 раз этот список, и еще 20% от него
    1.2 * a #тоже самое
    a / 5 #[0,1], длина списка 10,10/5=2,первые два элемента списка
    a // 5 #[4,9], каждый пятый элемент списка
    a / 2 #[0,1,2,3,4]
    a // 2 #[1,3,5,7,9]
    имеет все функций обычного list, по типу append, remove

XC:
    a = xc(1+5j)
    b = xc(9j)
    c = xc(0.1-0.5j)
    d = xc(12)

===== [№4] Циклы [№4] =====
Кол-во циклов в Epis: 2.Это while, for
Пример всех циклов трижды выводящих "Hello, World!"

While: 
i=0
while i<3:
    io.print("Hello, World!\n")
    i+=1

For:
for i in range(0,1,3): #range(start,step,stop) не путайте с расположением аргументов с пайтоном,в пайтоне range не обязательно писать 3 аргумента,а аргумент step в конце,а в Epis все три аргумента обязательны,и step посередине
    io.print("Hello, World!\n")

===== [№5] Работа с стан. и внеш. модулями [№5] =====
В отличий от многих языков, стандартный синтаксис языка разделен на стандарные модули, которые не надо импортировать

Стандартные библиотеки:
╭・io - работа с вводом и выводом и пару доп. функций
├・json - работа с JSON
├・math - математические константы и функций
╰・filework - работа с файлами

Для работы с внешними есть функций use() и unpack(), что они делают?
use: 
├・Эта функция возвращяет импортируемый пайтон-файл или стандартную библиотеку пайтона ввиде класса, как обычный import <lib>
├・Можно ввести название стандартной пайтон библиотеки, а можно путь к .PY/.PYD/.PYC файлу
├・use() в качестве аргумента использует строку
╰・Её содержимое нужно будет сохранять в объект, к которому мы и будем обращятся при работе с импортируемой библиотекой
Пример:
    re = use('re') # стандартная библиотека пайтона re
    mycustomlib = use('C:/path/to/library.py') # Путь к вашему самодельному модулю
    mycustomlib.print('print from my cutom lib')

unpack:
├・Он распаковывает классы и его методы в глобальное пространство языка
╰・По аналогий с пайтоном это как from <lib> import *, тоесть можно не обращятся к основному носителю метода, ибо теперь она есть ввиде функций

Для импорта конкретных атрибутов(функций, переменных, классов) можно в качестве второго аргумента use использовать кортеж с версий 1.0.7
Пример:
    sqrt, sin = use('math',('sqrt','sin')) # точно также с пользовательскими модулями

Пример: 
    username = io.input('Name: ')
    io.print(f"Hello, World and {username}!\n")
    unpack(io)
    print("Hi!\n")
    unpack(use('re'))
    if match(r'^\w*$',input('Text: ')):
        print("You write only letters")

Примеры кода со стандартными модулями:
После символа «:» написана версия в котором было последнее обновление функций
╭・IO・
io.print('Hello, World!') #вывод текста(с переносом строки) : 1.0.0
io.input('link') #ввод по приглашению : 1.0.0
io.ask('link',('option1','option2')) # ввод по выбору, если не подойдет ни под один из них, то вернет False, в инном случае выбранный вариант : 1.0.0
io.write(output_device,'Hello',format=val) # вывод в определенное устройство вывода('*' - вывод в консоль(без переноса строки),все остальное выводит текст в файл), format это тип данных(по умолчанию-str) : 1.0.1
io.read(input_device,'>>> ',format=val) # ввод с определенным устройством ввода, если первый аргумент это '*' будет запрашивать ввод в консоль, по приглажению '>>> ', если нет, то приглашение игнорируется и ввод идет через чтение файла : 1.0.1
io.map(func,arg) # применяет функцию func ко всем элементам arg, если это список или словарь : 1.0.0
io.len(string) # длина строки : 1.0.0
io.loading(steps,symbols,qw,s) # анимация загрузки в консоль : 1.0.0
╰・IO・ Подробнее и про остальные встроенные модули в 10 главе

===== [№6] Операторы [№6] =====
Операторы в EpisLang соответствует операторам Python
Арифметические:
├・a+b — операция сложения
├・a-b — операция вычитания
├・a*b — операция умножения
├・a/b — операция деления
├・a**b — операция возведения в степень
├・a//b — операция целочисленного деления
╰・a%b — операция остатка от от деления

Матричные:
╰・a@b — операция матричного умножения

Унарные:
├・+a — унарный плюс
╰・-a — унарный минус

Операторы распаковки:
├・*a — распаковка кортежа
╰・**a — распаковка словаря

Побитовые: 
├・a|b — побитовое ИЛИ/OR
├・a&b — побитовое И/AND
├・a^b — побитовое иИЛИ/XOR
├・a>>b — побитовый сдвиг вправо
├・a<<b — побитовый сдвиг влево
╰・~a — побитовая инверсия

Операторы сравнения:
├・a>b — больше
├・a<b — меньше
├・a==b — равно
├・a>=b — больше или равно
├・a<=b — меньше или равно
╰・a!=b — не равно

Логические:
├・a is b — a ссылается на ту же ячейку памяти, что и b
├・a is not b — a не ссылается на ту же ячейку памяти, что и b
├・a in b — a в b
├・a not in b — a не в b
├・a or b — логическое ИЛИ
├・a and b — логическое И
╰・not a — логическое НЕ

Лямбда-операторы: # Реализованно в версий v1.0.3
╰・(x,y) => (x+y) — Эквивалентно lambda x,y: x+y

Оператор проверки: #1.0.3
╰・(e ? 6) — Возвращает e если оно не равно None в инном случае возвращяется 6

Операторы присваивания:
├・a = b — a присваевается значение b
├・a += b — a прибавляется значение b
├・a -= b — a отнимается  значение b
├・a *= b — a умножается на значение b
├・a /= b — a делится на значение b
├・a **= b — a возводится в степень значения b
├・a //= b — a делится без остатка на значение b
├・a %= b — a остаток деления на значение b
├・a ?= b — эквивалент a = (a ? b) # 1.0.3
╰╰・пример:
    b = 5
    a = None
    a ?= b

===== [№7] Работа с переменными [№7] =====
Создание динамичной переменной, идентична пайтону:
num = number()

a = 1
f = 3.14
S = "Hi"
n = num(5.8)
fr = frac('3/7')

Создание переменный со статической типизацией:

class c(Var):
    pi = 3.14 # Константа
    a : int # Инициализация переменной, без присвоения значения
    b : num = 5.8 # присвоеные переменной типа и значение
    x : list # переменная которая всегда список
    y : list[int] # список где все элементы это целые числа(с 1.0.2)
    f : dict[int, str] # словарь, где все ключи-числа, элементы-строки(с версий 1.0.2)
    q : int | float | num | frac | complex | xc #может быть любым видом числа
    w : int | float #может быть или int или float
    k : list[int | float]
    def sqr(self,n : int) -> int: # функция принимает только int и возврашяет только int(с версий 1.0.1)
        if n<99: return n**2
        return "Hi"
c = c()
c.a = 12 #✓ переменной int дается int значение
c.pi = 2.8 #✗ константу нельзя изменить
c.b = 2 #✗ переменной number дается значение int
c.sqr(2) #✓ Дается int, возвращается int
c.sqr("g") #✗ Дается str
c.sqr(100) # ✗ Возвращяется str
c.q = c.w = 0 #✓
c.q = c.w = 6.8 #✓
c.q = num(3.7) #✓
c.w = num(5.7) #✗ w может быть только int или float

===== [№8] Условия [№8] =====
Для работы с условиями Epis унаследовал ключевые слова if elif else,выделение блоков такое-же
if 3>0:
    ...
elif 3==0:
    ...
else:
    ...

Также есть тернарники, пример:
a = 0
io.print(a, 0 if a%2==0 else 1)

Синтаксический сахар : с версий 1.0.3
a = 0
io.print(a, (a%2==0 ? 0 : 1)) #скобки обязательны

также в обоих случаях поддерживаются вложенность тернарников
0 if a%2==0 else (1 if a%3!=0 else 2)
или
(a%2==0 ? 0 : (a%3!=0 ? 1 : 2))

===== [№9] Работа с модулем mod.py [№9] =====

# для работы с mod.py вы должны находиться в той-же папке, где установлен интерпретатор, модуль уже установлен вместе с интерпретатором по умолчанию

Импорт:
name = use('mod.py','MODULE')
Импорт конкретной функций:
name = use('mod.py','MODULE').name

RANDOM:
random = use('mod.py','RANDOM')
random.randint(1,100) # случайное целое число от 1 до 100
random.choice([1,"apple",7.8]) # случаный элемент списка
random.shuffle([1,2,3,4,5]) # случайное расположение каждого элемента
random.uniform(1,10) # случайное число с плавающей запятой от 1 до 10

TIME:
time = use('mod.py','TIME')
time.now() # время сейчас
time.sleep(x) # остановить выполнение программы на x секунд

SYS:
sys = use('mod.py','SYS')
sys.args() # аргументы в консоли
sys.system(string) # вызывает строку в консоли

COLORS:
colors = use('mod.py','COLORS')

# чтобы покрасить текст в консоли:
colors.red('Hi!')
colors.green('Hi!')
colors.yellow('Hi!')
colors.blue('Hi!')
colors.magenta('Hi!')
colors.cyan('Hi!')
colors.white('Hi!')
colors.grey('Hi!')

# выделения:
bold('Hi!')
underline('Hi!')
reversed('Hi!')

===== [№10] Синтаксис [№10] =====
IO (то что не удалось вместить в №5)
io.loading(steps,symbols='/ ',qw=100,s=1000)
├・steps - количество кадров в анимаций загрузки
├・symbols - symbols[0] - это символ при заполненом ползунке загрузки,symbols[1] - это символ при пустом ползунке
├・qw - это максимальное кол-во процентов
╰・s - среднее ариф. кол-во милисекунд на кадр

примеры:
C:\EpisLang
λ epislang
Welcome to EpisLang v1.0.5/16544917112025 [2025-07-04]
        https://damir-dev.jimdofree.com/epis
>>> io.loading(100,'|.',1000,100)
>>> end
|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||| 1000%
C:\EpisLang
λ epislang
Welcome to EpisLang v1.0.5/16544917112025 [2025-07-04]
        https://damir-dev.jimdofree.com/epis
>>> io.loading(100,'|.',31,100)
>>> end
|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||| 031%

---
Filework
f = filework(mode) # создаем экземпляр класса filework
╰・mode - может быть "strict" или "free", по умолчанию "strict". "strict" - строгая система работы с файлами, не работающая за пределами папки где работает пользователь(мера безопасности). "free" - свободная система работы с файлами, может работать со всеми папками
f.delete(path,val) # Удаления файла path
├・path - путь к файлу
╰・val - Если истина, то удаляет, если ложь, то не удаляет файл указанный в path(Мера безопасности)
f.exists(path) # Проверка на существование файла
f.isdir(path) # Проверка на то, указанный путь это папка(return True), или нет(return False)

---
Math
Переменные:
math.inf - бесконечность(float, все остальное number)
math.pi - число пи с точность 256 после запятой
╰・Соотношение длины окружности к диаметру
math.e - число эйлера с точностью 256 после запятой
╰・Основание натурального логарифма
math.tau - число тау с точность 255 после запятой(фактически, но технически 256.256-ая цифра это ноль, и она не отображается)
╰・Соотношение длины окружности к радиусу(2pi)
math.phi - число фи с точность 256 после запятой
╰・Золотое сечение

Функций:
math.sqr(x) - квадрат числа
math.sqrt(x) - квадратный корень числа
math.fact(x) - факториал числа
math.subfact(x) - субфакториал числа
math.min(x) - самый маленький элемент аргумента(списки,кортежи)
math.max(x) - самый большой элемент аргумента(списки,кортежи)
math.abs(x) - модуль числа
math.hypot(x,y) - гипотинуза треугольника с катетами x и y
math.sign(x) - вид числа(x>0 -> 1(целое число), x=0 -> 0(ноль, ни то, ни другое), x<0 -> -1(отрицательное число))
math.eq(x,y,p) - равенство с погрешностью(по формуле abs(x-y)<p)
math.╰・p - это погрешность, по умолчанию 1e-9
math.sin(x) - синус
math.cos(x) - косинус
math.tan(x) - тангенс
math.log(x) - логарифм
math.floor(x) - округление к меньшему
math.ceil(x) - округление к большему
math.sum(args) - сумма всех арументов или всех элементов единственного аргумента

---
JSON
json.loads(string) - преобразовывает string в пайтон объект
json.dumps(obj) - преобразовывает пайтон объект в строку JSON

===== [№11] ... [№11] =====
...